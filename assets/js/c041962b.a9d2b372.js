"use strict";(self.webpackChunkjhipster_website=self.webpackChunkjhipster_website||[]).push([[7246],{28381:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var t=i(74848),s=i(28453);const l={title:"JHipster Domain Language (JDL) - Relationships",slug:"/jdl/relationships",last_update:{date:new Date("2019-11-03T12:00:00.000Z")}},o=void 0,a={id:"jdl/relationships",title:"JHipster Domain Language (JDL) - Relationships",description:"Relationship types",source:"@site/docs/jdl/relationships.mdx",sourceDirName:"jdl",slug:"/jdl/relationships",permalink:"/jdl/relationships",draft:!1,unlisted:!1,editUrl:"https://github.com/jhipster/jhipster.github.io/tree/main/docs/jdl/relationships.mdx",tags:[],version:"current",lastUpdatedAt:15727824e5,frontMatter:{title:"JHipster Domain Language (JDL) - Relationships",slug:"/jdl/relationships",last_update:{date:"2019-11-03T12:00:00.000Z"}},sidebar:"docsSidebar",previous:{title:"Enums",permalink:"/jdl/enums"},next:{title:"Options",permalink:"/jdl/options"}},r={},d=[{value:"Relationship types",id:"relationship-types",level:2},{value:"Relationship methods",id:"relationship-methods",level:2},{value:"Multiple relationship bodies",id:"multiple-relationship-bodies",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Examples",id:"examples",level:2},{value:"Basic example",id:"basic-example",level:3},{value:"With injected fields",id:"with-injected-fields",level:3},{value:"With methods",id:"with-methods",level:3},{value:"With options",id:"with-options",level:3},{value:"With required sides",id:"with-required-sides",level:3},{value:"Reflexive relationships",id:"reflexive-relationships",level:3},{value:"A note on required reflexive relationships",id:"a-note-on-required-reflexive-relationships",level:4},{value:"Commenting",id:"commenting",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"relationship-types",children:"Relationship types"}),"\n",(0,t.jsxs)(n.p,{children:["Mentioned after the ",(0,t.jsx)(n.code,{children:"relationship"})," keyword."]}),"\n",(0,t.jsx)(n.p,{children:"There are four relationship types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"OneToOne"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"OneToMany"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ManyToOne"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"ManyToMany"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To know more about relationships and what's possible to achieve, you can head\nto ",(0,t.jsx)(n.a,{href:"/managing-relationships",children:"the dedicated page"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"A note on plural names: JHipster handles them so that you don't have to in your relationships."}),"\n",(0,t.jsx)(n.h2,{id:"relationship-methods",children:"Relationship methods"}),"\n",(0,t.jsxs)(n.p,{children:["Mentioned after the source and destination entity, used with the ",(0,t.jsx)(n.code,{children:"with"})," keyword."]}),"\n",(0,t.jsx)(n.p,{children:"Supported methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"builtInEntity"}),": required when the destination entity is a built in entity like ",(0,t.jsx)(n.code,{children:"User"})," and ",(0,t.jsx)(n.code,{children:"Authority"})]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"multiple-relationship-bodies",children:"Multiple relationship bodies"}),"\n",(0,t.jsxs)(n.p,{children:["If you're tired of having ",(0,t.jsx)(n.em,{children:"n"})," relationships of the same type in your JDL file, don't worry! There's a solution."]}),"\n",(0,t.jsx)(n.p,{children:"Take this JDL sample for instance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  A to B\n}\nrelationship OneToOne {\n  B to C\n}\nrelationship OneToOne {\n  C to D\n}\nrelationship OneToOne {\n  D to A\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The solution consists in having every relationship body inside on relationship declaration, like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  A to B,\n  B to C,\n  C to D,\n  D to A\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This syntax is really useful when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You have lots of relationships of the same type,"}),"\n",(0,t.jsx)(n.li,{children:"You want to know what the relationships are,"}),"\n",(0,t.jsx)(n.li,{children:"You don't want to waste time looking for them in your JDL file(s)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,t.jsx)(n.p,{children:"Relationship declaration is done as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:'relationship (OneToMany | ManyToOne | OneToOne | ManyToMany) {\n  @<option>("<option value>")+ <from entity>[{<relationship name>[(<display field>)]}] to @<option>("<option value>")+ <to entity>[{<relationship name>[(<display field>)]}]+\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"(OneToMany | ManyToOne| OneToOne | ManyToMany)"})," is the type of your relationship,"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<option>"})," is one of the supported values: ",(0,t.jsx)(n.code,{children:"Id | OnDelete | OnUpdate"}),". Make sure to put this on the correct side of the relationship. First character case is not sensitive (jdl export will generate upper)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<option value>"})," is one of the fitting optional values for the given option: ",(0,t.jsx)(n.code,{children:"NO ACTION | RESTRICT | CASCADE | SET NULL | SET DEFAULT"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<from entity>"})," is the name of the entity owner of the relationship: the source,"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<to entity>"})," is the name of the entity where the relationship goes to: the destination,"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<relationship name>"})," is the name of the field having the other end as type,"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<display field>"})," is the name of the field that should show up in select boxes (default: ",(0,t.jsx)(n.code,{children:"id"}),"),"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"required"})," whether the injected field is required."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"with builtInEntity"})," whether the relationship destination is an built in entity"]}),"\n",(0,t.jsxs)(n.li,{children:["And you can have more than one relationship body","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["See the ",(0,t.jsx)(n.a,{href:"#multiple-relationship-bodies",children:"Multiple relationship bodies"})," section for more info!"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-example",children:"Basic example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  A to B\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Note that this example is the same as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  A{b} to B{a}\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Not specifying an injected field is the short form of having a bidirectional relationship."}),"\n",(0,t.jsx)(n.p,{children:"Another example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  A{b} to B\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This will generate a unidirectional relationship. You can only find entity B through entity A, but you cannot find entity A through entity B."}),"\n",(0,t.jsx)(n.h3,{id:"with-injected-fields",children:"With injected fields"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship ManyToMany {\n  A{b} to B{a}\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:'This is a bidirectional relationship, meaning that both entities will be generated with an "instance" of the other\nentity.'}),"\n",(0,t.jsx)(n.h3,{id:"with-methods",children:"With methods"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  A to User with builtInEntity\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"with-options",children:"With options"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:'relationship ManyToOne {\n   A to @OnDelete("SET NULL") @OnUpdate("CASCADE") B\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Note:"}),"\n",(0,t.jsx)(n.p,{children:"In Hibernate/JPA, deleting a parent entity in a many-to-one relationship with child entities depends on the relationship configuration and cascading behavior."}),"\n",(0,t.jsx)(n.p,{children:"Cascading Delete: When enabled, deleting the parent automatically deletes its associated children. This is achieved using CascadeType.REMOVE in the @OneToMany annotation on the parent entity class."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@OneToMany(mappedBy = "parent", cascade = CascadeType.REMOVE)\nprivate List<ChildEntity> children;\n'})}),"\n",(0,t.jsx)(n.p,{children:"No Cascading Delete: If not enabled, deleting a parent with children will result in a foreign key constraint violation. You must manually remove or disassociate the children before deleting the parent.\nUse cascading delete with caution as it can lead to unintended data loss."}),"\n",(0,t.jsx)(n.p,{children:"Alternative for Preventing Delete Error: Use the @OnDelete annotation in JDL which will configure the database schema for cascading delete or add cascade = CascadeType.REMOVE to the generated Java code (if applicable)."}),"\n",(0,t.jsx)(n.h3,{id:"with-required-sides",children:"With required sides"}),"\n",(0,t.jsx)(n.p,{children:"Used to make at least one relationship side required."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship ManyToMany {\n  A{b required} to B{a}\n}\n\n// or\n\nrelationship ManyToMany {\n  A{b} to B{a required}\n}\n\nor\n\nrelationship ManyToMany {\n  A{b(name) required} to B{a required}\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reflexive-relationships",children:"Reflexive relationships"}),"\n",(0,t.jsx)(n.p,{children:"A reflexive relationship is a relationship whose source & destination entities are the same."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship ManyToMany {\n  A{parent} to A{child}\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"a-note-on-required-reflexive-relationships",children:"A note on required reflexive relationships"}),"\n",(0,t.jsxs)(n.p,{children:["As noted ",(0,t.jsx)(n.a,{href:"https://github.com/jhipster/generator-jhipster/issues/11495",children:"here"}),", required relationships to the same entity\nare not supported. The issue is that a child must ",(0,t.jsx)(n.strong,{children:"always"})," have a parent, which in turn must have one too, etc.\nA possible workaround is to have explicit root and children entities."]}),"\n",(0,t.jsx)(n.h3,{id:"commenting",children:"Commenting"}),"\n",(0,t.jsx)(n.p,{children:"Adding comments for relationships is possible:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jdl",children:"relationship OneToOne {\n  /** This comment will be put before b in entity A*/\n  A{b}\n  to\n  /** This comment will be put before a in entity B*/\n  B{a}\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The same commenting rules are applied here.\nThese comments will later be added as Javadoc comments by JHipster. The JDL possesses its own kind of comment:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"// an ignored comment"}),"\n",(0,t.jsx)(n.li,{children:"/** not an ignored comment */"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Therefore, anything that starts with ",(0,t.jsx)(n.code,{children:"//"})," is considered an internal comment for JDL, and will not be counted as Javadoc.\nPlease note that the JDL Studio directives that start with ",(0,t.jsx)(n.code,{children:"#"})," will be ignored during parsing."]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const s={},l=t.createContext(s);function o(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);