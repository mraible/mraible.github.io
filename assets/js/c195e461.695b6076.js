"use strict";(self.webpackChunkjhipster_website=self.webpackChunkjhipster_website||[]).push([[3489],{15439:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=n(74848),s=n(28453);const r={title:"Using JHipster UAA for Microservice Security",slug:"/using-uaa/",last_update:{date:new Date("2016-08-25T00:00:00.000Z")}},o=void 0,a={id:"using-uaa",title:"Using JHipster UAA for Microservice Security",description:"JHipster UAA is a user accounting and authorizing service for securing JHipster microservices using the OAuth2 authorization protocol.",source:"@site/docs/using-uaa.mdx",sourceDirName:".",slug:"/using-uaa/",permalink:"/using-uaa/",draft:!1,unlisted:!1,editUrl:"https://github.com/jhipster/jhipster.github.io/tree/main/docs/using-uaa.mdx",tags:[],version:"current",lastUpdatedAt:14720832e5,frontMatter:{title:"Using JHipster UAA for Microservice Security",slug:"/using-uaa/",last_update:{date:"2016-08-25T00:00:00.000Z"}}},c={},l=[{value:"Architecture diagram",id:"architecture-diagram",level:2},{value:"1. Security claims of microservice architecture",id:"1-security-claims-of-microservice-architecture",level:2},{value:"1. Central authentication",id:"1-central-authentication",level:3},{value:"2. Statelessness",id:"2-statelessness",level:3},{value:"3. User/machine access distinction",id:"3-usermachine-access-distinction",level:3},{value:"4. Fine-grained access control",id:"4-fine-grained-access-control",level:3},{value:"5. Safe from attacks",id:"5-safe-from-attacks",level:3},{value:"6. Scalability",id:"6-scalability",level:3},{value:"2. Understanding OAuth2 in this context",id:"2-understanding-oauth2-in-this-context",level:2},{value:"3. Using JHipster UAA",id:"3-using-jhipster-uaa",level:2},{value:"Basic setup",id:"basic-setup",level:3},{value:"Understanding the components",id:"understanding-the-components",level:3},{value:"Refresh Tokens",id:"refresh-tokens",level:3},{value:"Common mistakes",id:"common-mistakes",level:3},{value:"<strong><em>Using the same signing key for production and staging</em></strong>",id:"using-the-same-signing-key-for-production-and-staging",level:4},{value:"<strong><em>Not using TLS</em></strong>",id:"not-using-tls",level:4},{value:"<strong><em>Using access tokens in URL</em></strong>",id:"using-access-tokens-in-url",level:4},{value:"<strong><em>Switching to symmetric signing keys</em></strong>",id:"switching-to-symmetric-signing-keys",level:4},{value:"4. Secure inter-service-communication using Feign clients",id:"4-secure-inter-service-communication-using-feign-clients",level:2},{value:"Using Eureka, Ribbon, Hystrix and Feign",id:"using-eureka-ribbon-hystrix-and-feign",level:3},{value:"Using <code>@AuthorizedFeignClients</code>",id:"using-authorizedfeignclients",level:3},{value:"5. Testing UAA applications",id:"5-testing-uaa-applications",level:2},{value:"Mocking Feign clients",id:"mocking-feign-clients",level:3},{value:"Emulating OAuth2 authentication",id:"emulating-oauth2-authentication",level:3},{value:"1. Enabling security in the mock Spring MVC context and inject the mock util",id:"1-enabling-security-in-the-mock-spring-mvc-context-and-inject-the-mock-util",level:4},{value:"2. Using the <code>OAuth2TokenMockUtil</code>",id:"2-using-the-oauth2tokenmockutil",level:4}];function h(e){const i={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"JHipster UAA is a user accounting and authorizing service for securing JHipster microservices using the OAuth2 authorization protocol."}),"\n",(0,t.jsxs)(i.p,{children:['To distinguish JHipster UAA from other "UAA"s such as ',(0,t.jsx)(i.a,{href:"https://github.com/cloudfoundry/uaa",children:"Cloudfoundry UAA"}),", JHipster UAA is a fully configured OAuth2 authorization server with the users and roles endpoints inside, wrapped into a usual JHipster application. This allows the developer to deeply configure every aspect of the user domain, without restricting on policies by other ready-to-use UAAs."]}),"\n",(0,t.jsx)(i.h2,{id:"architecture-diagram",children:"Architecture diagram"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Diagram",src:n(67033).A+"",width:"1024",height:"768"})}),"\n",(0,t.jsx)(i.h2,{id:"1-security-claims-of-microservice-architecture",children:"1. Security claims of microservice architecture"}),"\n",(0,t.jsx)(i.p,{children:"Before digging into OAuth2 and its application on JHipster microservices, it's important to clarify the claims to a solid security solution."}),"\n",(0,t.jsx)(i.h3,{id:"1-central-authentication",children:"1. Central authentication"}),"\n",(0,t.jsx)(i.p,{children:"Since microservices is about building mostly independent and autonomous applications, we want to have a consistent authentication experience, so the users won't notice their requests are served by different applications with possibly individual security configuration."}),"\n",(0,t.jsx)(i.h3,{id:"2-statelessness",children:"2. Statelessness"}),"\n",(0,t.jsx)(i.p,{children:"The core benefit of building microservices is scalability. So the chosen security solution shouldn't affect this. Holding the users session state on server becomes a tricky task, so a stateless solution is highly preferred in this scenario."}),"\n",(0,t.jsx)(i.h3,{id:"3-usermachine-access-distinction",children:"3. User/machine access distinction"}),"\n",(0,t.jsx)(i.p,{children:"There is a need of having a clear distinction of different users, and also different machines. Using microservice architecture leads to building a large multi-purpose data-center of different domains and resources, so there is a need to restrict different clients, such as native apps, multiple single page applications etc. in their access."}),"\n",(0,t.jsx)(i.h3,{id:"4-fine-grained-access-control",children:"4. Fine-grained access control"}),"\n",(0,t.jsx)(i.p,{children:"While maintaining centralized roles, there is a need of configuring detailed access control policies in each microservice. A microservice should be unaware of the responsibility of recognizing users, and must authorize incoming requests."}),"\n",(0,t.jsx)(i.h3,{id:"5-safe-from-attacks",children:"5. Safe from attacks"}),"\n",(0,t.jsx)(i.p,{children:"No matter how much problems a security solution may solve, it should be strong against vulnerabilities as best as possible."}),"\n",(0,t.jsx)(i.h3,{id:"6-scalability",children:"6. Scalability"}),"\n",(0,t.jsx)(i.p,{children:"Using stateless protocols is not a warranty of the security solution is scalable. In the end, there should not be any single point of failure. A counter-example is a shared auth database or single auth-server-instance, which is hit once per request."}),"\n",(0,t.jsx)(i.h2,{id:"2-understanding-oauth2-in-this-context",children:"2. Understanding OAuth2 in this context"}),"\n",(0,t.jsxs)(i.p,{children:["Using the OAuth2 protocol (note: it's a ",(0,t.jsx)(i.strong,{children:"protocol"}),", not a framework, not an application) is satisfying all 6 claims. It follows strict standards, what makes this solution compatible to other microservices as well, and remote systems, too. JHipster provides a couple of solutions, based on the following security design:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"JHipster UAA architecture",src:n(69536).A+"",width:"802",height:"800"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:'Every request to any endpoint of the architecture is performed via an "client"'}),"\n",(0,t.jsx)(i.li,{children:'A "client" is an abstract word for things like "Angular $http client", some "REST-Client", "curl", or anything able to perform requests.'}),"\n",(0,t.jsx)(i.li,{children:'A "client" may also be used in conjunction with user authentication, like the Angular $http in the frontend client application'}),"\n",(0,t.jsx)(i.li,{children:"Every microservice serving resources on endpoints (including the UAA), are resource servers"}),"\n",(0,t.jsx)(i.li,{children:"Blue arrows show clients authenticate on an Oauth authorization server"}),"\n",(0,t.jsx)(i.li,{children:"Green arrows show requests on resource servers performed by the client"}),"\n",(0,t.jsx)(i.li,{children:"The UAA server is a combination of authorization server and resource server"}),"\n",(0,t.jsx)(i.li,{children:"The UAA server is the owner of all the data inside the microservice applications (it approves automatically access to resource servers)"}),"\n",(0,t.jsx)(i.li,{children:'Clients accessing resources with user authentication, are authenticated using "password grant" with the client ID and secret safely stored in the gateway configuration files'}),"\n",(0,t.jsx)(i.li,{children:'Clients accessing resources without user, are authenticated using "client credentials grant"'}),"\n",(0,t.jsx)(i.li,{children:"Every client is defined inside UAA (web-app, internal, ...)"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This design may be applied to any microservice architecture independent from language or framework."}),"\n",(0,t.jsx)(i.p,{children:"As an addition, the following rules can be applied for access control:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:['User access is configured using "roles" and ',(0,t.jsx)(i.a,{href:"https://de.wikipedia.org/wiki/Role_Based_Access_Control",children:"RBAC"})]}),"\n",(0,t.jsxs)(i.li,{children:['Machines access is configured using "scopes" and ',(0,t.jsx)(i.a,{href:"https://de.wikipedia.org/wiki/Role_Based_Access_Control",children:"RBAC"})]}),"\n",(0,t.jsxs)(i.li,{children:["Complex access configuration is expressed using ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Attribute-Based_Access_Control",children:"ABAC"}),', using boolean expressions over both "roles" and "scopes"',"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:'example: hasRole("ADMIN") and hasScope("shop-manager.read", "shop-manager.write")'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"3-using-jhipster-uaa",children:"3. Using JHipster UAA"}),"\n",(0,t.jsx)(i.p,{children:"When scaffolding a JHipster microservice, you may choose the UAA options instead of JWT authentication."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Note"}),": the UAA solution is also using JWT, which are addressable to custom configuration as well as JWT, using default Spring Cloud Security."]}),"\n",(0,t.jsx)(i.h3,{id:"basic-setup",children:"Basic setup"}),"\n",(0,t.jsx)(i.p,{children:"The very basic setup consists of:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"A JHipster UAA server (as type of application)"}),"\n",(0,t.jsx)(i.li,{children:"At least one other microservice (using UAA authentication)"}),"\n",(0,t.jsx)(i.li,{children:"A JHipster gateway (using UAA authentication)"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This is the order in which it should be generated."}),"\n",(0,t.jsx)(i.p,{children:"In addition to the authentication type, the location of the UAA must be provided."}),"\n",(0,t.jsx)(i.p,{children:"For very basic usage, this setup is working the same way as it does for JWT authentication type, but with one more service."}),"\n",(0,t.jsx)(i.h3,{id:"understanding-the-components",children:"Understanding the components"}),"\n",(0,t.jsx)(i.p,{children:"The JHipster UAA server does three things out of the box:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"It serves the default JHipster user domain, containing user and account resource (this is done by gateway in JWT authentication)"}),"\n",(0,t.jsxs)(i.li,{children:["It implements ",(0,t.jsx)(i.code,{children:"AuthorizationServerConfigurerAdapter"}),' for OAuth2 and is defining basic clients ("web_app" and "internal")']}),"\n",(0,t.jsxs)(i.li,{children:["It serves the JWT public key on ",(0,t.jsx)(i.code,{children:"/oauth/token_key"}),", which has to be consumed by all other microservices"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"The choices of a database, cache solution, search engine, build tools and further JHipster options are open to the developer."}),"\n",(0,t.jsxs)(i.p,{children:["When a microservice boots up, it usually expects the UAA server is already up to share its public key. The service first calls ",(0,t.jsx)(i.code,{children:"/oauth/token_key"})," to fetch the public key and configure it for key signing (",(0,t.jsx)(i.code,{children:"JwtAccessTokenConverter"}),")."]}),"\n",(0,t.jsxs)(i.p,{children:["If the UAA is not up, the application will continue to start and fetch the public key at a later time. There are two properties - ",(0,t.jsx)(i.code,{children:"uaa.signature-verification.ttl"})," controls how long the key lives before it is fetched again, ",(0,t.jsx)(i.code,{children:"uaa.signature-verification.public-key-refresh-rate-limit"})," limits requests to UAA to avoid spamming it. These values are usually left at their default values. In any case, if verification fails, then the microservice will check if there's a new key. That way, keys can be replaced on the UAA and the services will catch up."]}),"\n",(0,t.jsx)(i.p,{children:"From this point there are two use cases that may happen in this basic setup: user calls and machine calls."}),"\n",(0,t.jsxs)(i.p,{children:["For the user calls, a login request is sent to the gateway's ",(0,t.jsx)(i.code,{children:"/auth/login"})," endpoint. This endpoint uses ",(0,t.jsx)(i.code,{children:"OAuth2TokenEndpointClientAdapter"}),' to send a request to the UAA authenticating with the "password" grant. Because this request happens on the gateway, the client ID and secret are not stored in any client-side code and are inaccessible to users. The gateway returns a new Cookie containing the token, and this cookie is sent with each request performed from the client to the JHipster backend.']}),"\n",(0,t.jsxs)(i.p,{children:["For the machine calls, the machine has to authenticate as a UAA using client credentials grant. JHipster provides a standard solution, described in ",(0,t.jsx)(i.a,{href:"#4-secure-inter-service-communication-using-feign-clients",children:"secure inter-service-communication using feign clients"})]}),"\n",(0,t.jsx)(i.h3,{id:"refresh-tokens",children:"Refresh Tokens"}),"\n",(0,t.jsx)(i.p,{children:"The general flow for refreshing access tokens happens on the gateway and is as follows:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Authentication is done via ",(0,t.jsx)(i.code,{children:"AuthResource"})," calling ",(0,t.jsx)(i.code,{children:"OAuth2AuthenticationService"}),"'s authenticate which will set Cookies."]}),"\n",(0,t.jsxs)(i.li,{children:["For each request, the ",(0,t.jsx)(i.code,{children:"RefreshTokenFilter"})," (installed by ",(0,t.jsx)(i.code,{children:"RefreshTokenFilterConfigurer"}),") checks whether the access token is expired and whether it has a valid refresh token."]}),"\n",(0,t.jsxs)(i.li,{children:["If so, then it triggers the refresh process via ",(0,t.jsx)(i.code,{children:"OAuth2AuthenticationService"})," refreshToken."]}),"\n",(0,t.jsxs)(i.li,{children:["This uses the ",(0,t.jsx)(i.code,{children:"OAuth2TokenEndpointClient"})," interface to send a refresh token grant to the OAuth2 server of choice, in our case UAA (via ",(0,t.jsx)(i.code,{children:"UaaTokenEndpointClient"}),")."]}),"\n",(0,t.jsx)(i.li,{children:"The result of the refresh grant is then used downstream as new cookies and set upstream (to the browser) as new cookies."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"common-mistakes",children:"Common mistakes"}),"\n",(0,t.jsx)(i.p,{children:"Here is a brief list of the very major things a developer should be aware of."}),"\n",(0,t.jsx)(i.h4,{id:"using-the-same-signing-key-for-production-and-staging",children:(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Using the same signing key for production and staging"})})}),"\n",(0,t.jsx)(i.p,{children:"It is strictly recommended to use different signing keys as much as possible. Once a signing key gets into wrong hands, it is possible to generate full access granting key without knowing login credentials of any user."}),"\n",(0,t.jsx)(i.h4,{id:"not-using-tls",children:(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Not using TLS"})})}),"\n",(0,t.jsx)(i.p,{children:"If attackers manage to intercept an access token, they will gain all the rights authorized to this token, until the token expires. There are a lot of ways to achieve that, in particular when there is no TLS encryption. This was not a problem in the days of version 1 of OAuth, because protocol level encryption was forced."}),"\n",(0,t.jsx)(i.h4,{id:"using-access-tokens-in-url",children:(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Using access tokens in URL"})})}),"\n",(0,t.jsx)(i.p,{children:"As of standard, access tokens can be either passed by URL, in headers, or in a cookie. From the TLS point of view, all three ways are secure. In practice passing tokens via URL is less secure, since there several ways of getting the URL from records."}),"\n",(0,t.jsx)(i.h4,{id:"switching-to-symmetric-signing-keys",children:(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Switching to symmetric signing keys"})})}),"\n",(0,t.jsx)(i.p,{children:"RSA is not required for JWT signing, and Spring Security does provide symmetric token signing as well. This also solves some problems, which make development harder. But this is insecure, since an attacker needs to get into one single microservice to be able to generate its own JWT tokens."}),"\n",(0,t.jsx)(i.h2,{id:"4-secure-inter-service-communication-using-feign-clients",children:"4. Secure inter-service-communication using Feign clients"}),"\n",(0,t.jsx)(i.p,{children:"Currently only JHipster UAA is providing an scalable approach of secure inter-service-communication."}),"\n",(0,t.jsx)(i.p,{children:"Using JWT authentication without manually forwarding JWTs from request to internal request forces microservices to call other microservices over the gateway, which involves additional internal requests per one master requests. But even with forwarding, it's not possible to cleanly separate user and machine authentication."}),"\n",(0,t.jsx)(i.p,{children:"Since JHipster UAA is based on OAuth2, all these problems are solved on protocol definition."}),"\n",(0,t.jsx)(i.p,{children:"This chapter covers how to get started with this."}),"\n",(0,t.jsx)(i.h3,{id:"using-eureka-ribbon-hystrix-and-feign",children:"Using Eureka, Ribbon, Hystrix and Feign"}),"\n",(0,t.jsx)(i.p,{children:"When one service wants to request data from another, finally all these four players come into play. So it is important, to briefly know what each of them is responsible for:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:'Eureka: this is where services (un-)register, so you can ask "foo-service" and get a set of IPs of instances of the foo-service, registered in Eureka.'}),"\n",(0,t.jsx)(i.li,{children:'Ribbon: when someone asked for "foo-service" and already retrieved a set of IPs, Ribbon does the load balancing over these IPs.'}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:['So to sum up, when we got a URL like "',(0,t.jsx)(i.a,{href:"http://uaa/oauth/token/",children:"http://uaa/oauth/token/"}),'" with 2 instances of JHipster UAA server running on 10.10.10.1:9999 and 10.10.10.2:9999, we may use Eureka and Ribbon to quickly transform that URL either to "',(0,t.jsx)(i.a,{href:"http://10.10.10.1:9999/oauth/token",children:"http://10.10.10.1:9999/oauth/token"}),'" or "',(0,t.jsx)(i.a,{href:"http://10.10.10.2:9999/oauth/token",children:"http://10.10.10.2:9999/oauth/token"}),'" using a Round Robin algorithm.']}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Hystrix: a circuit breaker system solving fall-back scenarios on service fails"}),"\n",(0,t.jsx)(i.li,{children:"Feign: using all that in a declarative style"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"In real world, there is no warranty of all instances of all services to be up. So Hystrix works as a circuit breaker, to handle failure scenarios in a well-defined way, using fallbacks."}),"\n",(0,t.jsxs)(i.p,{children:["But wiring and coding all these things manually is a lot of work: Feign provides the option of writing ",(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Ribbon"})})," load balanced REST clients for endpoints registered in ",(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Eureka"})}),", with fallback implementations controlled using ",(0,t.jsx)(i.strong,{children:(0,t.jsx)(i.em,{children:"Hystrix"})}),", using nothing more then an Java interfaces with some annotations."]}),"\n",(0,t.jsx)(i.p,{children:'So for inter-service-communication, Feign clients are very helpful. When one service needs a REST client to access an "other-service", serving some "other-resource", it\'s possible to declare an interface like:'}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'@FeignClient(name = "other-service")\ninterface OtherServiceClient {\n  @RequestMapping(value = "/api/other-resources")\n  List<OtherResource> getResourcesFromOtherService();\n}\n'})}),"\n",(0,t.jsx)(i.p,{children:"And then, using it via dependency injection, like:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"@Service\nclass SomeService {\n  private OtherServiceClient otherServiceClient;\n\n  @Inject\n  public SomeService(OtherServiceClient otherServiceClient) {\n    this.otherServiceClient = otherServiceClient;\n  }\n}\n"})}),"\n",(0,t.jsx)(i.p,{children:"Similar to Spring Data JPA, there is no need to implement that interface. But you may do so, if using Hystrix. Implemented classes of Feign client interfaces act as fallback implementations."}),"\n",(0,t.jsxs)(i.p,{children:["One open issue is, to make this communication secure using UAA. To accomplish this, there should be some request interceptor for Feign, which implements the client credentials flow from OAuth, to authorize the current service for requesting the other service. In JHipster, you use ",(0,t.jsx)(i.code,{children:"@AuthorizedFeignClients"})," instead. This is an annotation provided by JHipster, which does exactly that."]}),"\n",(0,t.jsxs)(i.h3,{id:"using-authorizedfeignclients",children:["Using ",(0,t.jsx)(i.code,{children:"@AuthorizedFeignClients"})]}),"\n",(0,t.jsx)(i.p,{children:'Considering the above Feign client should be used to an "other-service", which\nserves protected resources, the interface must be annotated like this:'}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'@AuthorizedFeignClient(name = "other-service")\ninterface OtherServiceClient {\n  @RequestMapping(value = "/api/other-resources")\n  List<OtherResource> getResourcesFromOtherService();\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"note"}),": Due to a bug in Spring Cloud, it's currently not possible to use a different\nnotation for the service name, as"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'@AuthorizedFeignClient("other-service")\n'})}),"\n",(0,t.jsx)(i.p,{children:"or"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'@AuthorizedFeignClient(value = "other-service")\n'})}),"\n",(0,t.jsx)(i.p,{children:"The REST client automatically gets authorized with your UAA server, when there is no valid access token stored in memory."}),"\n",(0,t.jsx)(i.p,{children:'This approach addresses a scenario when machine request run over a separate OAuth client not referring to an user session. This is important, in particular when entity auditing is used on a request, issued by another request in another service. As an alternative, the access token of the initial request may be forwarded to further calls. Currently, there is no "default solution" provided by JHipster.'}),"\n",(0,t.jsx)(i.h2,{id:"5-testing-uaa-applications",children:"5. Testing UAA applications"}),"\n",(0,t.jsx)(i.h3,{id:"mocking-feign-clients",children:"Mocking Feign clients"}),"\n",(0,t.jsx)(i.p,{children:"Components working with Feign clients should be testable. Using Feign in tests the same way it is used in production would force the JHipster Registry and the UAA server to be up and reachable to the same machine where the tests are run. But in most cases, you don't want to test that Feign itself works (it usually does), but your components using Feign clients."}),"\n",(0,t.jsxs)(i.p,{children:["To test components, which are using feign clients inside is possible using ",(0,t.jsx)(i.code,{children:"@MockBean"}),", which is part of spring boot since 1.4.0."]}),"\n",(0,t.jsxs)(i.p,{children:["Here is an example, testing ",(0,t.jsx)(i.code,{children:"SomeService"})," works as expected, with mocked values for the client:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"@RunWith(SpringRunner.class)\n@SpringBootTest(App.class)\npublic class SomeServiceTest {\n\n    @MockBean\n    private OtherServiceClient otherServiceClient;\n\n    @Inject\n    private SomeService someService;\n\n    @Test\n    public void testSomeService() {\n        given(otherServiceClient.getResourcesFromOtherService())\n        .willReturn(Arrays.asList(new OtherResource(...));\n\n        someService.performActionWhichInkvokesTheAboveMentionedMethod();\n\n        //assert that your application is in the desired state\n    }\n}\n"})}),"\n",(0,t.jsx)(i.p,{children:"So with this technology you are simulating the behavior of the other service, and provide expected resource entity, which would come from the origin.\nAll Beans injecting a client will behave as mocked, so you can focus on the logic of these Beans."}),"\n",(0,t.jsx)(i.h3,{id:"emulating-oauth2-authentication",children:"Emulating OAuth2 authentication"}),"\n",(0,t.jsx)(i.p,{children:"Using Spring's integration tests against the REST controllers is usually bypassing the security configuration, since it would make testing hard, when the only intention is to prove the controller is functional doing what it should do. But sometimes, testing a controller's security behavior is part of testing, too."}),"\n",(0,t.jsxs)(i.p,{children:["For this use-case, JHipster is providing an component called ",(0,t.jsx)(i.code,{children:"OAuth2TokenMockUtil"}),", which can emulate a valid authentication without forcing the user or client to exist."]}),"\n",(0,t.jsx)(i.p,{children:"To use this feature, two things have to be done:"}),"\n",(0,t.jsx)(i.h4,{id:"1-enabling-security-in-the-mock-spring-mvc-context-and-inject-the-mock-util",children:"1. Enabling security in the mock Spring MVC context and inject the mock util"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"@Inject\nprivate OAuth2TokenMockUtil tokenUtil;\n\n@PostConstruct\npublic void setup() {\n    this.restMockMvc = MockMvcBuilders\n        .webAppContextSetup(context)\n        .apply(springSecurity())\n        .build();\n}\n"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:(0,t.jsxs)(i.em,{children:["In this test no single instance of the controller has to be mocked, but the\napplication's ",(0,t.jsx)(i.code,{children:"WebApplicationContext"})]})})}),"\n",(0,t.jsxs)(i.h4,{id:"2-using-the-oauth2tokenmockutil",children:["2. Using the ",(0,t.jsx)(i.code,{children:"OAuth2TokenMockUtil"})]}),"\n",(0,t.jsx)(i.p,{children:'The util offers a method "oaut2authentication", which is usable to MockMvc "with" notation. Currently it can be configured to mock a authentication with the following fields:'}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"username"}),"\n",(0,t.jsx)(i.li,{children:"roles (Set<String>)"}),"\n",(0,t.jsx)(i.li,{children:"scope (Set<String>)"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Here is an example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'@Test\npublic void testInsufficientRoles() {\n    restMockMvc.peform(\n        get("url/requiring/ADMIN/role")\n        .with(tokenUtil.oauth2Authentication("unpriveleged.user@example.com", Sets.newSet("some-scope"), Sets.newSet("ROLE_USER")))\n    ).andExpect(status().isForbidden());\n}\n'})})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},69536:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/jhipster_uaa-014acad4b698a3efb39b1d96e00bb74c.png"},67033:(e,i,n)=>{n.d(i,{A:()=>t});const t=n.p+"assets/images/microservices_architecture_detail.002-754db5cd5f5ed8d26cd2d325ec8976f3.png"},28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var t=n(96540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);