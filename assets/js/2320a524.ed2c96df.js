"use strict";(self.webpackChunkjhipster_website=self.webpackChunkjhipster_website||[]).push([[3140],{59217:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>t,metadata:()=>r,toc:()=>h});var a=n(74848),s=n(28453);const t={title:"Using a cache",slug:"/using-cache/",last_update:{date:new Date("2017-02-10T18:40:00.000Z")}},c=void 0,r={id:"options/using-cache",title:"Using a cache",description:"A cache can be used at two levels in JHipster:",source:"@site/docs/options/using-cache.mdx",sourceDirName:"options",slug:"/using-cache/",permalink:"/using-cache/",draft:!1,unlisted:!1,editUrl:"https://github.com/jhipster/jhipster.github.io/tree/main/docs/options/using-cache.mdx",tags:[],version:"current",lastUpdatedAt:1486752e6,frontMatter:{title:"Using a cache",slug:"/using-cache/",last_update:{date:"2017-02-10T18:40:00.000Z"}},sidebar:"docsSidebar",previous:{title:"Doing API-First development",permalink:"/doing-api-first-development/"},next:{title:"Using Oracle",permalink:"/using-oracle/"}},o={},h=[{value:"Common configuration",id:"common-configuration",level:2},{value:"Caching with Ehcache",id:"caching-with-ehcache",level:2},{value:"Caching with Caffeine",id:"caching-with-caffeine",level:2},{value:"Caching with Hazelcast",id:"caching-with-hazelcast",level:2},{value:"Caching with Infinispan",id:"caching-with-infinispan",level:2},{value:"Caching with Memcached",id:"caching-with-memcached",level:2},{value:"Caching with Redis",id:"caching-with-redis",level:2}];function d(e){const i={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.p,{children:"A cache can be used at two levels in JHipster:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["With the Spring Cache abstraction, which is a specific question when your application is generated, and which uses the Spring Boot ",(0,a.jsx)(i.code,{children:"@EnableCaching"})," annotation. This needs to be tuned according to your specific business needs, and works at a higher level than the Hibernate 2nd-level cache."]}),"\n",(0,a.jsx)(i.li,{children:"As an Hibernate 2nd-level cache, a caching solution can give a huge performance boost to your application, and this is what people usually do with JHipster. Please note that this option is only available for SQL databases, and if you have selected to use Spring Cache."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Spring Cache and the Hibernate 2nd-level cache will use the same caching solution, but do not work at the same level: we do not recommend to use both for the same objects, as this will make cache invalidation issues even more complex. Instead, we recommend you use:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Spring Cache for higher-level or aggregate objects, like you typically have with DTOs"}),"\n",(0,a.jsx)(i.li,{children:"The Hibernate 2nd-level cache for entities mapped to the database, in order to reduce the number of SQL requests"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"JHipster supports the following cache implementations:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Ehcache,"}),"\n",(0,a.jsx)(i.li,{children:"Caffeine,"}),"\n",(0,a.jsx)(i.li,{children:"Hazelcast,"}),"\n",(0,a.jsx)(i.li,{children:"Infinispan,"}),"\n",(0,a.jsx)(i.li,{children:"Memcached,"}),"\n",(0,a.jsx)(i.li,{children:"Redis."}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"They are all detailed below."}),"\n",(0,a.jsx)(i.h2,{id:"common-configuration",children:"Common configuration"}),"\n",(0,a.jsxs)(i.p,{children:["Caches are configured in the ",(0,a.jsx)(i.code,{children:"CacheConfiguration"})," class, and can also be tuned using the JHipster ",(0,a.jsx)(i.a,{href:"/common-application-properties/",children:"common application properties"}),"."]}),"\n",(0,a.jsx)(i.h2,{id:"caching-with-ehcache",children:"Caching with Ehcache"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"http://www.ehcache.org/",children:"Ehcache"}),' is the default cache with monoliths in JHipster. Ehcache starts up very fast, so it\'s a perfect solution for "normal" monoliths.']}),"\n",(0,a.jsx)(i.p,{children:"With JHipster, Ehcache cannot work as a distributed cache, as it doesn't have an API allowing to add new nodes programmatically"}),"\n",(0,a.jsxs)(i.p,{children:["Ehcache is configured in the ",(0,a.jsx)(i.code,{children:"CacheConfiguration"})," Spring configuration bean, which defines 2 properties (",(0,a.jsx)(i.code,{children:"time-to-live-seconds"})," and ",(0,a.jsx)(i.code,{children:"max-entries"}),") in the JHipster ",(0,a.jsx)(i.a,{href:"/common-application-properties/",children:"common application properties"}),". More properties can be added in your application's specific ",(0,a.jsx)(i.code,{children:"ApplicationProperties"})," Spring configuration bean."]}),"\n",(0,a.jsxs)(i.p,{children:["By default, ",(0,a.jsx)(i.code,{children:"time-to-live-seconds"})," has a default value of 3600 seconds (1 hour) both in ",(0,a.jsx)(i.code,{children:"dev"})," and in ",(0,a.jsx)(i.code,{children:"prod"})," mode, and ",(0,a.jsx)(i.code,{children:"max-entries"})," has a default value of 100 entries in ",(0,a.jsx)(i.code,{children:"dev"})," mode and 1,000 entries in ",(0,a.jsx)(i.code,{children:"prod"})," mode."]}),"\n",(0,a.jsx)(i.p,{children:"Those values should be tuned depending on your specific business needs, and the JHipster monitoring screen can help you better understand cache usage in your application. Please also refer to the Ehcache documentation to fine-tune those values."}),"\n",(0,a.jsx)(i.h2,{id:"caching-with-caffeine",children:"Caching with Caffeine"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"https://github.com/ben-manes/caffeine",children:"Caffeine"})," is a ",(0,a.jsx)(i.a,{href:"https://github.com/ben-manes/caffeine/wiki/Benchmarks",children:"high performance"}),", ",(0,a.jsx)(i.a,{href:"https://github.com/ben-manes/caffeine/wiki/Efficiency",children:"near optimal"})," caching library and is an alternative to Ehcache for use with monoliths in JHipster."]}),"\n",(0,a.jsx)(i.p,{children:"Similar to Ehcache, Caffeine cannot work as a distributed cache."}),"\n",(0,a.jsxs)(i.p,{children:["Jhipster generates a default configuration for Caffeine which is identical to Ehcache. However you may wish to add additional options to fine tune it to your needs. Caffeine cache configuration is done in ",(0,a.jsx)(i.code,{children:"CacheConfiguration"})," Spring configuration bean whereas your application specific properties can be added to ",(0,a.jsx)(i.code,{children:"ApplicationProperties"})," bean. You might find the following three files useful in defining your own Caffeine configuration."]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["We use the ",(0,a.jsx)(i.a,{href:"https://github.com/ben-manes/caffeine/blob/master/jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/CaffeineConfiguration.java",children:(0,a.jsx)(i.code,{children:"CaffeineConfiguration"})})," class within the ",(0,a.jsx)(i.code,{children:"CacheConfiguration"})," bean to add Caffeine properties."]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:["\n",(0,a.jsxs)(i.p,{children:["You might find ",(0,a.jsx)(i.a,{href:"https://github.com/ben-manes/caffeine/blob/master/jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java",children:(0,a.jsx)(i.code,{children:"TypesafeConfigurator"})})," along with ",(0,a.jsx)(i.a,{href:"https://github.com/ben-manes/caffeine/blob/master/jcache/src/main/resources/reference.conf",children:(0,a.jsx)(i.code,{children:"reference.conf"})})," as a reference to all supported Caffeine properties."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"caching-with-hazelcast",children:"Caching with Hazelcast"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"https://hazelcast.com/",children:"Hazelcast"})," can work as a local cache (like Ehcache), but can also work as a distributed cache. As a result:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"It is the default option for microservices, as we expect microservices to scale"}),"\n",(0,a.jsxs)(i.li,{children:["It is the default option for gateways, as we expect them to scale, and as Hazelcast is used to distribute the ",(0,a.jsx)(i.a,{href:"/api-gateway/#rate-limiting",children:"gateway rate-limiting information"})]}),"\n",(0,a.jsxs)(i.li,{children:["When used within a monolith, Hazelcast needs to have the ",(0,a.jsx)(i.a,{href:"/jhipster-registry/",children:"JHipster Registry"})," configured manually in order to scale"]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"For scaling applications, Hazelcast will use the configured service discovery in order to find new nodes, and scale horizontally. With microservices and gateways, this will work both with the JHipster Registry and Consul, and for monoliths this will only work when you manually configure the JHipster Registry."}),"\n",(0,a.jsx)(i.p,{children:"When a new node is added, it will register itself to the service discovery (for instance, it will be available in the JHipster Registry), and look for other nodes of the same type. If it finds one or several nodes of the same type, it will create a clustered cache with them: you should see in the logs of each node a message, like in the following example:"}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{children:"[172.18.0.10]:5701 [dev] [3.7]\nMembers [4] {\nMember [172.18.0.10]:5701 - 3cbddfcd-0229-4cd5-be55-4611927a9071 this\nMember [172.18.0.5]:5701 - 204d457d-f6fe-43f2-8e8d-497e96b3f08e\nMember [172.18.0.14]:5701 - 7804d535-86fb-46be-b2a5-d7801dc6a4df\nMember [172.18.0.11]:5701 - 6114ae28-56cd-4840-a575-4d73a6003744\n}\n"})}),"\n",(0,a.jsx)(i.p,{children:"To work better with Hazelcast, JHipster includes support for the Hazelcast Management Center:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Please note that you can only monitor 2 nodes for free, as this is a proprietary product. But that's already enough for testing your application."}),"\n",(0,a.jsxs)(i.li,{children:["It is configured using JHipster ",(0,a.jsx)(i.a,{href:"/common-application-properties/",children:"common application properties"}),", using the key ",(0,a.jsx)(i.code,{children:"jhipster.cache.hazelcast.management-center"}),", in your ",(0,a.jsx)(i.code,{children:"application-dev.yml"})," and ",(0,a.jsx)(i.code,{children:"application-prod.yml"})," files. Please note that it is turned off by default."]}),"\n",(0,a.jsxs)(i.li,{children:["JHipster generates a Docker Compose configuration to run the Hazelcast Management Center. Please read our ",(0,a.jsx)(i.a,{href:"/docker-compose/",children:"Docker Compose documentation"}),", and run the application using ",(0,a.jsx)(i.code,{children:"docker-compose -f src/main/docker/hazelcast-management-center.yml up -d"}),"."]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"caching-with-infinispan",children:"Caching with Infinispan"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"https://infinispan.org/",children:"Infinispan"})," is a highly performant caching solution that can work as an in-memory local cache as well as clustered cache. It offers support for multiple cache modes:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://infinispan.org/docs/9.4.x/user_guide/user_guide.html#local_mode",children:"Local"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://infinispan.org/docs/9.4.x/user_guide/user_guide.html#invalidation_mode",children:"Invalidation"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://infinispan.org/docs/9.4.x/user_guide/user_guide.html#replicated_mode",children:"Distributed"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://infinispan.org/docs/9.4.x/user_guide/user_guide.html#distribution_mode",children:"Replicated"})}),"\n",(0,a.jsx)(i.li,{children:(0,a.jsx)(i.a,{href:"https://infinispan.org/docs/9.4.x/user_guide/user_guide.html#scattered_mode",children:"Scattered"})}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"With JHipster, Infinispan can be used:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"As an implementation of the Spring Cache abstraction"}),"\n",(0,a.jsx)(i.li,{children:"As an Hibernate 2nd level cache"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Following is the pre-configured default configuration:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Entities operate in invalidation cache mode"}),"\n",(0,a.jsxs)(i.li,{children:["For application-specific caching, three caching configurations are pre-defined","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"local-app-data"})," for caching data local to the nodes"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"dist-app-data"})," for distributed caching of data across nodes (number of copies determined by the distributed replica count)"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"repl-app-data"})," for replicating data across nodes"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["Eviction, time-to-live and max-entries for each of the individual operation mode in the cache and the replica count for the distributed mode can be fine-tuned using the JHipster ",(0,a.jsx)(i.a,{href:"/common-application-properties/",children:"common application properties"}),". Fine tune the properties in ",(0,a.jsx)(i.code,{children:"jhipster.cache.infinispan"})," for application-specific caching and ",(0,a.jsx)(i.code,{children:"spring.jpa.properties"})," for Hibernate's 2nd level cache."]}),"\n",(0,a.jsxs)(i.p,{children:["If the JHipster Registry is enabled, then the node list will be populated from the registry. If the JHipster Registry is not enabled, node discovery will be based on the default transport settings defined in the ",(0,a.jsx)(i.code,{children:"config-file"})," packaged within the Infinispan Jar. Infinispan supports discovery natively for most of the platforms like Kubernets/OpenShift, AWS, Azure and Google."]}),"\n",(0,a.jsx)(i.p,{children:"Though Infinispan 9.0.0.Final GA and later releases added support to run Infinispan embedded caching applications on Kubernetes and OpenShift by making use of native KUBE_PING discovery, Hibernate dependency is not yet updated to 9.x releases and hence native discovery is not supported on Kubernetes and OpenShift. However you can run the applications by making use of JHipster Registry for instances discovery."}),"\n",(0,a.jsx)(i.h2,{id:"caching-with-memcached",children:"Caching with Memcached"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"https://memcached.org/",children:"Memcached"})," is an Open Source distributed cache. It is quite different from the other cache implementations supported by JHipster:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Memcached cannot work as an Hibernate 2nd level cache, it only supports the Spring Cache abstraction."}),"\n",(0,a.jsx)(i.li,{children:"Memcached only works with a remote server, there is no local cache. As such, your objects are always serialized/deserialized and go through the network, which means it is probably less efficient if you have a small set of objects that could fit in memory."}),"\n",(0,a.jsx)(i.li,{children:"It scales, and is cheap to operate. Most big cloud providers like Heroku, GCP or AWS have support for Memcached. As such, it is a lot easier to have a distributed (and cheap) Memcached cluster, than with the other caching implementations."}),"\n"]}),"\n",(0,a.jsxs)(i.p,{children:["JHipster uses the popular ",(0,a.jsx)(i.a,{href:"https://github.com/killme2008/xmemcached",children:"Xmemcached"})," Java client for Memcached, and configures its most important properties using the usual JHipster ",(0,a.jsx)(i.a,{href:"/common-application-properties/",children:"common application properties"}),"."]}),"\n",(0,a.jsxs)(i.p,{children:["Please note that each cache must be configured as a specific Spring bean inside the ",(0,a.jsx)(i.code,{children:"CacheConfiguration"})," configuration bean."]}),"\n",(0,a.jsx)(i.p,{children:"As Memcached needs to serialize/deserialize objects in its classloader, it doesn't work when using the Spring Boot devtools (which uses a specific classloader to do hot reload of application classes). This is why Memcached is turned off by default in dev mode."}),"\n",(0,a.jsxs)(i.p,{children:["As always with JHipster, a Docker Compose configuration is provided so you can start a Memcached server on your machine. In order to use it, please run ",(0,a.jsx)(i.code,{children:"docker-compose -f src/main/docker/memcached.yml up -d"}),"."]}),"\n",(0,a.jsx)(i.h2,{id:"caching-with-redis",children:"Caching with Redis"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.a,{href:"https://redis.io/",children:"Redis"})," is an Open Source, in-memory data structure store that can be used as a performant caching solution. Depending on your configuration, you can choose to use Redis as a single server node or as a distributed cache."]}),"\n",(0,a.jsxs)(i.p,{children:["JHipster uses ",(0,a.jsx)(i.a,{href:"https://redisson.org/",children:"Redisson"})," as the redis Java client mainly for 2 reasons:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"It is highly recommended by Redis"}),"\n",(0,a.jsx)(i.li,{children:"It offers a JCache (JSR-107) implementation"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"It allows both to stay consistent with the other caches since we are using JCache implementation when available and to share the same redis connection between Spring cache and the Hibernate 2nd level cache."})]})}function l(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>c,x:()=>r});var a=n(96540);const s={},t=a.createContext(s);function c(e){const i=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(t.Provider,{value:i},e.children)}}}]);