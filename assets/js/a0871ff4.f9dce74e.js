"use strict";(self.webpackChunkjhipster_website=self.webpackChunkjhipster_website||[]).push([[528],{14989:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var t=n(74848),s=n(28453);const l={title:"Boost infinite scroll performance with Slice",slug:"/tips/019_tip_infinite_scroll_with_slice.html",last_update:{date:new Date("2016-11-12T22:22:00.000Z")}},o=void 0,r={id:"tips/tip_infinite_scroll_with_slice",title:"Boost infinite scroll performance with Slice",description:"Tip submitted by @nkolosnjaji",source:"@site/docs/tips/019_tip_infinite_scroll_with_slice.mdx",sourceDirName:"tips",slug:"/tips/019_tip_infinite_scroll_with_slice.html",permalink:"/tips/019_tip_infinite_scroll_with_slice.html",draft:!1,unlisted:!1,editUrl:"https://github.com/jhipster/jhipster.github.io/tree/main/docs/tips/019_tip_infinite_scroll_with_slice.mdx",tags:[],version:"current",lastUpdatedAt:147898932e4,sidebarPosition:19,frontMatter:{title:"Boost infinite scroll performance with Slice",slug:"/tips/019_tip_infinite_scroll_with_slice.html",last_update:{date:"2016-11-12T22:22:00.000Z"}},sidebar:"docsSidebar",previous:{title:"Kubernetes and Google Cloud SQL",permalink:"/tips/018_tip_kubernetes_and_google_cloud_sql.html"},next:{title:"Using Docker containers as localhost on Mac/Windows",permalink:"/tips/020_tip_using_docker_containers_as_localhost_on_mac_and_windows.html"}},a={},c=[{value:"Boost performance of pagination with infinite scrolling using Slice",id:"boost-performance-of-pagination-with-infinite-scrolling-using-slice",level:2}];function d(e){const i={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:(0,t.jsxs)(i.strong,{children:["Tip submitted by ",(0,t.jsx)(i.a,{href:"https://github.com/nkolosnjaji",children:"@nkolosnjaji"})]})}),"\n",(0,t.jsx)(i.h2,{id:"boost-performance-of-pagination-with-infinite-scrolling-using-slice",children:"Boost performance of pagination with infinite scrolling using Slice"}),"\n",(0,t.jsxs)(i.p,{children:["Pagination with infinite scrolling is using Spring Data Page to retrieve entities from your database.\nThis will trigger two queries, one to fetch entities and second for ",(0,t.jsx)(i.code,{children:"count all"})," to determine the total items for paging. Infinite scrolling doesn't need information about the total size but only if there is a next page to load. To avoid ",(0,t.jsx)(i.code,{children:"count all"})," query which can be an expensive operation when working with large datasets, use ",(0,t.jsx)(i.a,{href:"http://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/Slice.html",children:"Slice"})," instead of Page which will boost performance of infinite scrolling."]}),"\n",(0,t.jsxs)(i.p,{children:["We will use a custom HTTP header ",(0,t.jsx)(i.code,{children:"X-Has-Next-Page"})," to send information to front-end infinite-scroll plugin."]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Define new method in your Entity repository:"}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"Slice<YourEntity> findSliceBy(Pageable pageable);\n"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Define new static method in ",(0,t.jsx)(i.code,{children:"PaginationUtil.java"})," located in ",(0,t.jsx)(i.code,{children:"web/rest/util"})," package"]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'public static HttpHeaders generateSliceHttpHeaders(Slice<?> slice) {\n  HttpHeaders headers = new HttpHeaders();\n  headers.add("X-Has-Next-Page", "" + slice.hasNext());\n  return headers;\n}\n'})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Modify REST controller to call Slice instead of Page and generate new HTTP headers."}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'@GetMapping("/<YourEntities>")\n@Timed\npublic ResponseEntity<List<Repo>> getAllRepos(Pageable pageable)\n    throws URISyntaxException {\n    Slice<YourEntity> slice = repoRepository.findSliceBy(pageable);\n    HttpHeaders headers = PaginationUtil.generateSliceHttpHeaders(slice);\n    return new ResponseEntity<>(slice.getContent(), headers, HttpStatus.OK);\n}\n'})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Define new view model in ",(0,t.jsx)(i.code,{children:"entity.controller.js"})]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-js",children:"vm.hasNextPage = false;\n"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Extract HTTP header value from response and assign it to view model in"}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-js",children:"function onSuccess(data, headers) {\n    vm.hasNextPage = headers('X-Has-Next-Page') === \"true\";\n    ...\n}\n"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Use view model with infinite-scroll plugin in ",(0,t.jsx)(i.code,{children:"<your-entities>.html"})]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-html",children:'<tbody infinite-scroll="vm.loadPage(vm.page + 1)" infinite-scroll-disabled="!vm.hasNextPage">\n'})})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>r});var t=n(96540);const s={},l=t.createContext(s);function o(e){const i=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);